<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: agentify.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: agentify.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/* Here we define agentify, the agent base class, and all other functions and definitions they rely on. */

/**
 * @typedef {Feature} Point
 * @property {Array} geometry.coordinates - This should be a single array with 2 elements: the point's coordinates.
 *
 * An extension of {@link Feature} for points.
 */

/**
 * Callback that gives a feature with appropriate geometry and properties to represent an agent.
 *
 * @callback agentFeatureMaker
 * @param {number} i - A number used to determine the agent's coordinates and other properties.
 * @returns {Point} - A GeoJSON Point feature with properties and coordinates for agent i.
 */

/**
 * A standard featureMaker callback, which sets an agent's location as the center of a unit on the map.
 * 
 * @type {agentFeatureMaker}
 */
function seqUnitAgentMaker(i) {
//modulo the number of units, adding agents to units once the total num of units is exceeded
	let unit = i,
	center_point = turf.centroid(Object.values(this.layers.units._layers)[i].feature);
	center_point.properties.unit_id = i;
	center_point.properties.place = {"unit": unit};
	
	return center_point;
}

/**
 * Generate some number of agents and place them on the map.
 *
 * @param {number} count - The desired number of agents.
 * @param {agentFeatureMaker} agentFeatureMaker - A callback that determines an agent i's feature properties and geometry (always a Point).
 */
function agentify(count, agentFeatureMaker) {
	let agentmap = this,
	agents_existing = agentmap.agents.length;
	for (let i = agents_existing; i &lt; agents_existing + count; i++) {
		//Callback function aren't automatically bound to the agentmap.
		let boundFeatureMaker = agentFeatureMaker.bind(agentmap),
		feature = boundFeatureMaker(i),
		new_agent = new Agent(feature, i, agentmap);
		new_agent.place = feature.properties.place;
		this.layers.agents.addData(new_agent.feature);
		new_agent.layer = Object.values(agentmap.layers.agents._layers)[new_agent.id];
		this.agents.push(new_agent);
	}
}

/**
 * The main class representing individual agents.
 *
 * @class Agent
 * @param {Point} feature - A GeoJSON point feature representing the agent.
 * @param {number} id - A unique ID for the agent.
 * @param {Agentmap} agentmap - The agentmap instance in which the agent exists.
 * @property {Point} feature - A geoJSON point feature representing the agent.
 * @property {number} feature.AgentMap_id - The agent's instance id, so it can be accessed from inside the Leaflet layer. To avoid putting the actual instance inside the feature object.
 * @property {number} id - A unique ID for the agent.
 * @property {Agentmap} agentmap - The agentmap instance in which the agent exists.
 * @property {Object} layer - The layer inside the leaflet map corresponding to this Agent.
 * @property {Object.&lt;string, number>} place - The id of the place (unit, street, etc.) where the agent is currently at.
 * @property {Object} travel_state - Properties detailing information about the agent's trip that change sometimes, but needs to be accessed by future updates.
 * @property {boolean} travel_state.traveling - Whether the agent is currently on a trip.
 * @property {?Point} travel_state.current_point - The point where the agent is currently located.
 * @property {?Point} travel_state.goal_point - The point where the agent is traveling to.
 * @property {?number} travel_state.lat_dir - The latitudinal direction. -1 if traveling to lower latitude (down), 1 if traveling to higher latitude (up).
 * @property {?number} travel_state.lng_dir - The longitudinal direction. -1 if traveling to lesser longitude (left), 1 if traveling to greater longitude (right).
 * @property {?number} travel_state.slope - The slope of the line segment formed by the two points between which the agent is traveling at this time during its trip.
 * @property {Array} travel_state.path - A sequence of pairs of LatLngs, such that the second latLng of a pair is the first latLng of the pair that comes after it. The agent will move between one pair, then the pair will be popped off, then move between the next pair, and so on, until there are no pairs left and the trip along the path is complete; or, until the travel_staste is changed/reset.
 * @property {?function} update_func - Function to be called on each update.
 */
function Agent(feature, id, agentmap) {
	this.feature = feature,
	this.feature.AgentMap_id = id,
	this.id = id,
	this.agentmap = agentmap,
	this.layer = null,
	this.place = null,
	this.travel_state = {
		traveling: false,
		current_point: null,
		goal_point: null,
		lat_dir: null,
		lng_dir: null,
		slope: null,
		//add to docs: the list of steps remaining (point pairs) to move between, popped after each arrival
		path: [],
	};
	this.update_func = null
}

/**
 * Delete the agent from the AgentMap.
 */	
Agent.prototype.delete = function() {
	delete this.agentmap.agents[this.id];
	this.agentmap.layers.agents.removeLayer(this.layer);
};

/**
 * Stop the agent from traveling, reset all the properties of its travel state.
 */
Agent.prototype.resetTravelState = function() {
	for (let key in this.travel_state) {
		this.travel_state[key] = key === "traveling" ? false : 
			key === "path" ? [] :
			null;
	}
};

/**
 * Set the agent up to travel to some point on the map.
 *
 * @param {Point} goal_point - The point to which the agent should travel.
 */
Agent.prototype.setTravelTo = function(goal_point) {
	let state = this.travel_state;
	
	state.traveling = true,
	state.current_point = this.layer.getLatLng(),
	state.goal_point = L.latLng(goal_point),
	
	//Negating so that neg result corresponds to the goal being rightward/above, pos result to it being leftward/below.
	state.lat_dir = Math.sign(- (state.current_point.lat - state.goal_point.lat)),
	state.lng_dir = Math.sign(- (state.current_point.lng - state.goal_point.lng)),
	
	state.slope = Math.abs(((state.current_point.lat - state.goal_point.lat) / (state.current_point.lng - state.goal_point.lng)));
};

/**
 * Specific methods for traveling between units, within units, and along streets, so as to keep track of where the agent is. Should be used
 * to move the agent around, not setTravelTo. If the agent should move in some other way, a wrapper for setTravelTo should be created that
 * keeps track of the agent's place at any given time accordingly.
 */

/**
 * Set the agent up to travel to a unit, via streets.
 *
 * @param {number} unit_id - The id of the unit to which the agent should travel; unit_id must not be the id of the agent's current place.
 */
Agent.prototype.setTravelToUnit = function(unit_id) {
	return;
};

/**
 * Set the agent up to travel to a point within the unit he is in.
 *
 * @param {Point} point - A point within the unit the agent is currently in.
 */
Agent.prototype.setTravelInUnit = function(point) {
	if (turf.contains(unit, point)) {
		this.setTravelTo(point);
	}
};

/**
 * Set the agent up to travel to a point along a street, via streets.
 *
 * @param {number} goal_street_id - The id of the unit to which the agent should travel; unit_id must not be the id of the agent's current place.
 * @param {number} distance - The distance into the street that the agent should travel.
 * @param {Array&lt;LatLngs>} street_point - The coordinates of a point on a street to which the agent should travel; null by default, otherwise "distance" will be ignored; if point is provided, street_id is optional; if not provided, it will search through all streets for the point; if provided, it will search that particular street.
 */
Agent.prototype.setTravelToStreet = function(goal_street_id, distance, street_point = null) {
	if (street_point === null) {
		let street_id;

		if (typeof(this.place.unit) === "number") {
			//make custom unit function to get the unit
			let street_id;
			this.agentmap.layers.units.eachLayer(function(layer) {
				if (layer.feature.properties.id === this.place.unit) {
					street_id = layer.feature.properties.street_id;
				}
			});

			let unit_door = this.agentmap.getUnitDoor(this.place.unit), 
			current_coords = this.getLatLng(),
			current_to_door = [current_coords, unit_door],
			unit_street_door = this.agentmap.getStreetNearDoor(this.place.unit),
			door_to_street = [unit_door, unit_street_door];
			this.travel_state.path.push(current_to_door, door_to_street);	
		}
		else {
			street_id = this.place.street;
		}
//make custom layer function to get the street
		let street;
		this.agentmap.layers.streets.eachLayer(function (layer) {
			if (layer.feature.properties.id === street_id) {
				street = layer.feature;
			}
		})

		let goal_street_point = turf.along(street, distance).geometry.coordinates,
		street_segment = [unit_street_door, goal_street_point];
		this.travel_state.path.push(street_segment);
	}
	else {
		return;
	}
};

/**
 * Continue to move the agent directly from one point to another, without regard for streets, 
 * according to the time that has passed since the last movement. Also simulate intermediary movements
 * during the interval between the current call and the last call to moveDirectly, by splitting that interval 
 * up with some precision (agentmap.settings.movement_precision) into some number of parts (steps_inbetween) 
 * and moving slightly for each of them, for more precise collision detection than just doing it after each 
 * call to moveDirectly from requestAnimationFrame (max, 60 times per second) would allow. Limiting movements to
 * each requestAnimationFrame call was causing each agent to skip too far ahead at each call, causing moveDirectly
 * to not be able to catch when the agent is within 1 meter of the goal_point... splitting the interval since the last
 * call up and making intermediary calls fixes that.
 *
 * @param {number} rAF_time - The time when the browser's most recent animation frame was released.
 */
Agent.prototype.moveDirectly = function(animation_interval, intermediary_interval, steps_inbetween) {
	let state = this.travel_state;
	
	//Fraction of the number of ticks since the last call to move the agent forward by.
	//Only magnitudes smaller than hundredths will be added to the lat/lng at a time, so that it doesn't leap ahead too far;
	//as the tick_interval is usually &lt; 1, and the magnitude will be the leap_fraction multiplied by the tick_interval.
	const leap_fraction = .001;

	let move = (function(tick_interval) {
		if (state.goal_point.distanceTo(state.current_point) &lt; 1) {
			state.path.shift();
			
			if (state.path.length === 0) {
				this.resetTravelState();
			}
			else {
				this.setTravelTo(this.layer.getLatLng(), state.path[0][1]);
			}
		}

		let lat_change = state.lat_dir * state.slope * (leap_fraction * tick_interval),
		lng_change = state.lng_dir * (leap_fraction * tick_interval),
		new_lat_lng = L.latLng([state.current_point.lat + lat_change, state.current_point.lng + lng_change]);
		this.layer.setLatLng(new_lat_lng);
		state.current_point = new_lat_lng;
	}).bind(this);
	
	//Intermediary movements.
	for (let i = 0; i &lt; steps_inbetween; ++i) {
		move(intermediary_interval);
		if (state.traveling === false) {
			return;
		}
	}
	
	//Latest requested movement.
	if (state.traveling === true) {
		//why is this lynchpin
		latest_interval = animation_interval - (this.agentmap.settings.movement_precision * steps_inbetween);
		move(latest_interval);
	}
	else {
		return;
	}
};

/**
 * Make the agent proceed with whatever it's doing and update its properties before the browser draws the next frame.
 *
 * @param {number} rAF_time - The time when the browser's most recent animation frame was released.
 */
Agent.prototype.update = function(animation_interval, intermediary_interval, steps_inbetween) {
	this.update_func();
	//Set all movement controls and everything else in user-provided update_func; e.g. if (agentmap.ticks % 60 == 0 &amp;&amp; this.place.unit == 9) { this.setTravelToUnit(); }
	if (this.travel_state.traveling) {
		this.moveDirectly(animation_interval, intermediary_interval, steps_inbetween);
	}
}

/**
 * Get a point through which an agent can exit/enter a unit.
 *
 * @param {number} unit_id - The unique id of the unit whose door you want.
 * @returns {LatLng} - The coordinates of the center point of the segment of the unit parallel to the street.
 */
function getUnitDoor(unit_id) {
	let unit = Object.values(this.layers.units._layers)[unit_id],
	unit_spec = unit.getLatLngs()[0],
	side_a = unit_spec[0],
	side_b = unit_spec[1],
	door = 	L.latLngBounds(side_a, side_b).getCenter();
	
	return door;
}

/**
 * Get the point on the adjacent street in front of the unit's door.
 *
 * @param {number} unit_id - The unique id of the unit whose door's corresponding point on the street you want.
 * @returns {LatLng} - The coordinates point of the adjacent street directly in front of unit's door.
 */
function getStreetNearDoor(unit_id) {
	let unit_anchors = reversedCoordinates(Object.values(this.layers.units._layers)[unit_id].feature.properties.street_anchors.map(
		anchor => anchor.geometry.coordinates)),
	street_point = L.latLngBounds(...unit_anchors).getCenter();
	
	return street_point;
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Agent.html">Agent</a></li><li><a href="Agentmap.html">Agentmap</a></li></ul><h3>Global</h3><ul><li><a href="global.html#agentify">agentify</a></li><li><a href="global.html#buildingify">buildingify</a></li><li><a href="global.html#generateUnitFeatures">generateUnitFeatures</a></li><li><a href="global.html#getAllFeatures">getAllFeatures</a></li><li><a href="global.html#getStreetNearDoor">getStreetNearDoor</a></li><li><a href="global.html#getUnitAnchors">getUnitAnchors</a></li><li><a href="global.html#getUnitDoor">getUnitDoor</a></li><li><a href="global.html#noOverlaps">noOverlaps</a></li><li><a href="global.html#reversedCoordinates">reversedCoordinates</a></li><li><a href="global.html#seqUnitAgentMaker">seqUnitAgentMaker</a></li><li><a href="global.html#unitsOutOfStreets">unitsOutOfStreets</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Sat May 12 2018 15:48:07 GMT-0400 (Eastern Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
